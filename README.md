# predictor

### Дисклеймер [для ревьюеров]
1. Программа писалась более четырех лет назад, когда мой написания на python, а также опыт применения моделей машинного обучения был не богат.
2. Программа писалась для самообразования и исследования предиктивных моделей, соответственно в ней нет промышленного кода, работающего надежно даже на утюге и в любых условиях.
3. Многие решения сейчас я сделал бы совсем по другому, и данный код не отражает моего текущего уровня знаний в области стека технологий ML&DS.



## Описание
Торговый робот для платформы Metrader5. Текущая версия работает только под Windows 10, что связано с зависимостью платформы Metatrader от Windows. Есть версия под Linux (Ubuntu) с более сложной схемой взаимодействия (добавлены сервисные компоненты взаимодействия с metatrader, запущеной из под wine).
Одним из принципов при написании программы был - минимум зависимостей от внешних библиотек, поэтому используется минимальный необходимый набор пакетов.


## Архитектура
Торговый робот состоит из двух основных компонент:
1. Серверная часть, выполняющая обучение/дообучение модели, предиктивные функции, функции хранения и предоставления данных клиенту. Зависимости: tensorflow, pandas, numpy, sqlite3
2. Клиентская часть, советник (торговый робот), выполняющий запросы прогнозов у сервера, отправку ордеров, контроль результата, управление счетом в рамках торговой стратегии.

Схема работы серверной части: при запуске серверной части загружает котировки с сервера Metatrader, запускает предварительное обучение. После предварительного обучения запускает основной цикл планировщика задач, в котором два типа задач со своими таймерами:
    - добавление прогноза в собственную БД и
    - дообучение на свежих данных.

#### Python компоненты
start.py - приложение, точка входа для серверной части. Запускается на машине с установленной платформой Metatrader5

server.py - Серверная часть, выполняет:
- коммуникации с сервером котировок Metatrader
- вычисляет прогнозы и сохраняет в БД
- предоставляет данные по запросу через http

predictor.py - модуль с классом Predictor вычисляющим прогноз и функции для предварительного обучения модели

models.py - набор предиктивных моделей (в том числе экспериментальные) и вспомогательных функций

dataloader.py - модуль с классом загрузки и подготовки датасета

mt5common.py - интерфейсы взаимодействия с серверами Metatrader

dbcommon.py - функции работы с базой данных (sqlite3)

adviser.py - отдельная программа (от остальных компонент) самостоятельно взаимодействующая с серверами Metatrader, выставляющая ордера, управляющая стратегией торговли.

train.ipynb - блокнот для независимых экспериментов с моделями


#### MQL5 компоненты

*mql5/Experts/Papaka/robert.mq5* - основная программа - советник. Запускается на платформе Metatrader. Требует установленные компоненты /Include

*mql5/Experts/Papaka/MMTE.mq5* - устаревший вариант robert.mq5

#### config.json
Основные настройки хранятся в config.json

#### Docker
docker/* - различные докер-файлы. В основном предназначены для дообучения модели в различной конфигурации железа, независимо от сервеной части. Дообученая модель через планировщик может заменять "старую" модель.


## Модель предсказаний
Эксперименты проводились с разными моделями

**Модель:** регрессионная (были эксперименты категориальной моделью предсказания со скорингом).
Предсказание осуществляется по входному окну временного ряда фиксированной длины. 
Опробованы комбинации архитектур LSTM, Dense, Conv1d, MultiheadAttention
Наиболее эффективные по показателям размер/вычислительная сложность/точность/скорость сходимости обучения: models.t1, models.red, models.dense_boost, models.scored_boost [категориальная]
**Входные данные:** Размерность сэмпла (входного тензора) - фиксированная. Используются только данные изменений котировок, свечного графика. Размерность входного окна, период котировок, размерность выходного окна прогноза настраивается в config.json.
**Выход:** одномерный тензор фиксированной длины (в простом случае - длина 1, то есть следующее значение).
**Работа с данными прошлых периодов:** Возможен пересчет прошедших периодов для заданного символа (торгового инструмента).
**Оптимизатор:** Adam, NAdam
**Функции потери и метрики:** 
MAE,
MSE,
Clipped MAE [models.ClippedMAE() - вариант MAE с защитой от выбросов],
Clipped MSE [models.ClippedMSE() - вариант MSE с защитой от выбросов],
Clipped sparse_categorical_crossentropy [models.ClippedSCE() - для категориального варианта модели],
TanhE [models.TanhE() - тангенциальная MSE],
Гауссова MSE [models.esum2() - ]
ROCAUC для категориальной модели
**Регуляризация:** L1, L2, BatchNormalization, LayerNormalization, Dropout
**Активации:**: Помимо классических, также используются
```python
def f_log(x):
    return tf.math.log(tf.exp(1.0) + tf.abs(x))

def f_logtanh(x):
    return tf.math.log(tf.exp(1.0) + tf.abs(x)) * tf.tanh(x)  # type: ignore
```

**Предобработки:** Эксперименты с различными преобразованиями в разных моделях:
Скользящее среднее
```python
def moving_average(a, n=3):
    ret = np.cumsum(a, dtype=float)
    ret[n:] = ret[n:] - ret[:-n]
    return ret[n - 1 :] / n
```

DCT
```python
def f_dct(x):
    return tf.signal.dct(x, n=64, norm="ortho")
```

Wavelets: были эсперименты с 1d и 2d вейвлетами Добеши db8, db6, rbio3.1 и другими (пакет pywt). Посмотреть можно в outdated/patterns.py

Бинаризация
```python
def embed(v, min_v, max_v, dim):
    """Возвращает бинарный вектор, длины dim"""
    step_size = dim / (max_v - min_v)
    v = max(min_v, min(max_v - 0.0000001, v))
    n = int((v - min_v) * step_size)
    # result = np.zeros(dim, dtype="float64")
    result = np.full(dim, 0.1, dtype="float64")
    result[n] = 1
    return result


def unembed(n: int, min_v: float, max_v: float, dim: int) -> float:
    step_size = float((max_v - min_v) / dim)
    v = min_v + n * step_size
    return v
```